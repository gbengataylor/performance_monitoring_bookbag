:guid: %guid%
:user: %user%
:markup-in-source: verbatim,attributes,quotes
:source-highlighter: highlight.js
[[quarkus]]
= Developing the Quarkus Application

In this section you will:

* Develop a REST API with Quarkus that consumes memory and CPU
* Add a Statistics persistent entity to store metrics in a PostgreSQL database
* Configure the application
* Develop some tests to validate the behavior of the application
* Test the application locally
* Run the application locally
* Check a few metrics locally

When you created your repository from the GitHub template, you should have a directory called `quarkus-app` in your current directory.
This is the root of the Quarkus microservice source code that we will be using in this section.

== The Quarkus REST Resource

The Quarkus application is made of a simple REST resource that consumes memory and CPU.
The resource is defined in the `QuarkusResource` class.
Create a new file called `QuarkusResource.java`, under the `src/main/java/io/containerapps/javaruntime/workshop/quarkus` folder.
Then add the following to the header of the class.
As you can see, it's a JAX-RS resource that exposes the `/quarkus` path.

[[quarkus-listing-rest-resource-1]]
.Header of the Quarkus REST Resource
[source,java,indent=0,role=copy]
----
package io.containerapps.javaruntime.workshop.quarkus;

import javax.ws.rs.DefaultValue;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.QueryParam;
import javax.ws.rs.core.MediaType;
import java.lang.System.Logger;
import java.time.Duration;
import java.time.Instant;
import java.util.HashMap;
import java.util.List;

import static java.lang.System.Logger.Level.INFO;
import static java.lang.invoke.MethodHandles.lookup;

@Path("/quarkus")
@Produces(MediaType.TEXT_PLAIN)
public class QuarkusResource {

    private static final Logger LOGGER = System.getLogger(lookup().lookupClass().getName());

    private final StatisticsRepository repository;

    public QuarkusResource(StatisticsRepository statisticsRepository) {
        this.repository = statisticsRepository;
    }
}
----

Let's add a `hello` method returning *_Hello World_*, so we can quickly check if our endpoint responds or not.

[[quarkus-listing-rest-resource-2]]
.Hello Method
[source,java,indent=0,role=copy]
----
    @GET
    public String hello() {
        LOGGER.log(INFO, "Quarkus: hello");
        return "Quarkus: hello";
    }
----

Let's now add a `cpu` method that consumes CPU depending on a few optional parameters.

* `iterations`: the more iterations you have, the more CPU it consumes.
* `db`: if this parameter is set to true, the statistics are stored in the database.
That allows us to check the impact of the database on the CPU consumption.
* `desc`: any optional description you want to persist in the database

[[quarkus-listing-rest-resource-3]]
.CPU Method
[source,java,indent=0,role=copy]
----
    @Path("/cpu")
    public String cpu(@QueryParam("iterations") @DefaultValue("10") Long iterations,
                      @QueryParam("db") @DefaultValue("false") Boolean db,
                      @QueryParam("desc") String desc) {
        LOGGER.log(INFO, "Quarkus: cpu: {0} {1} with desc {2}", iterations, db, desc);
        Long iterationsDone = iterations;

        Instant start = Instant.now();
        if (iterations == null) {
            iterations = 20000L;
        } else {
            iterations *= 20000;
        }

        while (iterations > 0) {
            if (iterations % 20000 == 0) {
                try {
                    Thread.sleep(20);
                } catch (InterruptedException ie) {
                }
            }
            iterations--;
        }

        if (db) {
            Statistics statistics = new Statistics();
            statistics.type = Type.CPU;
            statistics.parameter = iterations.toString();
            statistics.duration = Duration.between(start, Instant.now());
            statistics.description = desc;
            repository.persist(statistics);
        }

        String msg = "Quarkus: CPU consumption is done with " + iterationsDone + " iterations in " + Duration.between(start, Instant.now()).getNano() + " nano-seconds.";
        if (db) {
            msg += " The result is persisted in the database.";
        }
        return msg;
    }
----

Now add a `memory` method that consumes memory depending on a few optional parameters.

* `bites`: the more bits you have, the more memory it consumes.
* `db`: if this parameter is set to true, the statistics are stored in the database.
* `desc`: any optional description you want to persist in the database

[[quarkus-listing-rest-resource-4]]
.Memory Method
[source,java,indent=0,role=copy]
----
    @GET
    @Path("/memory")
    public String memory(@QueryParam("bites") @DefaultValue("10") Integer bites,
                         @QueryParam("db") @DefaultValue("false") Boolean db,
                         @QueryParam("desc") String desc) {
        LOGGER.log(INFO, "Quarkus: memory: {0} {1} with desc {2}", bites, db, desc);

        Instant start = Instant.now();
        if (bites == null) {
            bites = 1;
        }

        HashMap hunger = new HashMap<>();
        for (int i = 0; i < bites * 1024 * 1024; i += 8192) {
            byte[] bytes = new byte[8192];
            hunger.put(i, bytes);
            for (int j = 0; j < 8192; j++) {
                bytes[j] = '0';
            }
        }

        if (db) {
            Statistics statistics = new Statistics();
            statistics.type = Type.MEMORY;
            statistics.parameter = bites.toString();
            statistics.duration = Duration.between(start, Instant.now());
            statistics.description = desc;
            repository.persist(statistics);
        }

        String msg = "Quarkus: Memory consumption is done with " + bites + " bites in " + Duration.between(start, Instant.now()).getNano() + " nano-seconds.";
        if (db) {
            msg += " The result is persisted in the database.";
        }
        return msg;
    }
----

Let's also create a method to retrieve the statistics from the database.
This is very easy to do with https://quarkus.io/guides/hibernate-orm-panache[Panache].

[[quarkus-listing-rest-resource-5]]
.Method Returning all the Statistics
[source,java,indent=0,role=copy]
----
    @GET
    @Path("/stats")
    @Produces(MediaType.APPLICATION_JSON)
    public List<Statistics> stats() {
        LOGGER.log(INFO, "Quarkus: retrieving statistics");
        return Statistics.findAll().list();
    }
----

At this stage the code does not compile yet because there are a few missing classes.
Let's create them now.

== Transactions and ORM

When the database is enabled, the statistics are stored in the database.
For that we need a `Statistics` entity with a few enumerations that will be mapped to the PostgreSQL database.
Create the `Statistics.java` entity in the `src/main/java/io/containerapps/javaruntime/workshop/quarkus` folder.

[[quarkus-listing-entity]]
.Statistics Entity
[source,java,indent=0,role=copy]
----
package io.containerapps.javaruntime.workshop.quarkus;

import io.quarkus.hibernate.orm.panache.PanacheEntity;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Table;
import java.time.Duration;
import java.time.Instant;

@Entity
@Table(name = "Statistics_Quarkus")
public class Statistics extends PanacheEntity {

    @Column(name = "done_at")
    public Instant doneAt = Instant.now();
    public Framework framework = Framework.QUARKUS;
    public Type type;
    public String parameter;
    public Duration duration;
    public String description;
}

enum Type {
    CPU, MEMORY
}

enum Framework {
    QUARKUS, MICRONAUT, SPRINGBOOT
}
----

For manipulating the entity, we need a repository.
Create the `StatisticsRepository.java` class under the same package.
Notice that `StatisticsRepository` is a https://quarkus.io/guides/hibernate-orm-panache[Panache Repository] that extends the `PanacheRepository` class.

[[quarkus-listing-repository]]
.Statistics Repository
[source,java,indent=0,role=copy]
----
package io.containerapps.javaruntime.workshop.quarkus;

import io.quarkus.hibernate.orm.panache.PanacheRepository;

import javax.enterprise.context.ApplicationScoped;
import javax.transaction.Transactional;

@ApplicationScoped
@Transactional
public class StatisticsRepository implements PanacheRepository<Statistics> {

}
----

== Compiling the Quarkus Application

You should have all the code to compile the application.
To make sure you have all the code and dependencies, run the following command in the `quarkus-app` folder:

[source,shell,role=copy]
----
mvn compile
----

[TIP]
====
Besides using Maven commands directly in the IDE Terminal you can use the pre-defined commands available as Tasks in your Workspace.
To access these commands just open the Task Manager view at left menu of your IDE (see screenshot below) and choose the task named `01: Quarkus - JVM Package` which triggers a `mvn package -DskipTests` in a terminal.

image::../imgs/module-3/VSCode_task_manager_mvn_package.gif[Task Manager - JVM Package]

All these Tasks are defined as `commands` in the project's *Devfile* (`$PROJECT_SOURCE/devfile.yaml`) following the link:https://devfile.io[Devfile.io] standard.
====

[NOTE]
====
At this point you may be asking yourself about the Maven dependencies, since we haven't touched the project's `pom.xml`. 
That's true. To make things a bit easier during the Lab, we already set all the project dependencies for you. 
You can check the `quarkus-app/pom.xml` file by opening it in the editor, if you want to.
====

== Configuring the Quarkus Application

Because we will run our application in different environments (dev, test and prod), we need to configure our runtime for such.

To make sure our 3 microservices can run side by side, we need to configure the listening port of the Quarkus application.
To have this service exposed on the port 8701, add the following configuration in the `src/main/resources/application.properties` file.

[[quarkus-listing-config]]
.Configuration Properties
[source,properties,indent=0, role=copy]
----
quarkus.http.port=8701
----

During development and testing (inner-loop) we will be using a InMemory Database (H2 Db). To configure Quarkus to use H2 InMem DB in dev and test, add the following properties.

.Configuration Properties
[source,properties,indent=0, role=copy]
----
# Dev Config
%dev.quarkus.http.port=8701

# Use InMem H2 DB for dev and test profiles
%dev.quarkus.datasource.db-kind=h2
%dev.quarkus.datasource.jdbc.url=jdbc:h2:mem:test
%dev.quarkus.hibernate-orm.database.generation=drop-and-create
%dev.quarkus.hibernate-orm.log.sql=true

# Testing config
%test.quarkus.datasource.db-kind=h2
----

== Testing the Quarkus Application Locally

Now, to make sure that the application works as expected, we need to write some tests.
For that we will use https://quarkus.io/guides/getting-started-testing[Quarkus Test Framework] that is based on https://junit.org/junit5/[JUnit 5] and use https://github.com/rest-assured/rest-assured[RESTAssured].

A very common need is to start services which your Quarkus application depends on before the Quarkus application starts for testing. For instance, in our application, we need a DataBase instance (H2 in our case) in order to execute our test scenario. To address this need, Quarkus provides `@io.quarkus.test.common.QuarkusTestResource` annotation, which allows you to use an implementation of `io.quarkus.test.common.QuarkusTestResourceLifecycleManager`. For more details on this feature, see link:https://quarkus.io/guides/getting-started-testing#quarkus-test-resource[Starting services before the Quarkus application starts] in the link:https://quarkus.io/guides/getting-started-testing[Quakus Testing Guide].

Thankfully, Quarkus provides an implementation for H2 Database out of the box (`io.quarkus.test.h2.H2DatabaseTestResource`) which starts an H2 database for your Tests.

[NOTE]
====
Quarkus also integrates with https://www.testcontainers.org[Testcontainers], which can automatically start a Database using Docker (if present in your local dev environment) with its https://quarkus.io/guides/dev-services[DevServices] feature. But this is outside the scope of this workshop.
====

Create the `QuarkusResourceTest.java` class under the `src/test/java/io/containerapps/javaruntime/workshop/quarkus` folder.
Then add the following to the header of the class.

[[quarkus-listing-test-1]]
.Header of the Test Class
[source,java,indent=0,role=copy]
----
package io.containerapps.javaruntime.workshop.quarkus;

import io.quarkus.test.common.QuarkusTestResource;
import io.quarkus.test.h2.H2DatabaseTestResource;
import io.quarkus.test.junit.QuarkusTest;
import org.junit.jupiter.api.Test;

import static io.restassured.RestAssured.given;
import static org.hamcrest.CoreMatchers.*;

@QuarkusTest
@QuarkusTestResource(H2DatabaseTestResource.class)
public class QuarkusResourceTest {
}
----

First, let's write a test to check if the `hello` method returns the right _Hello World_ string.

[[quarkus-listing-test-2]]
.Testing the Hello Endpoint
[source,java,indent=0,role=copy]
----
  @Test
  public void testHelloEndpoint() {
      given()
        .when().get("/quarkus")
        .then()
          .statusCode(200)
          .body(is("Quarkus: hello"));
  }
----

Then, we write another test to check that the `cpu` method consumes CPU and takes the right parameters.

[[quarkus-listing-test-3]]
.Testing the CPU Endpoint
[source,java,indent=0,role=copy]
----
    @Test
    public void testCpuWithDBAndDescEndpoint() {
        given().param("iterations", 1).param("db", true).param("desc", "Java17")
          .when().get("/quarkus/cpu")
          .then()
            .statusCode(200)
            .body(startsWith("Quarkus: CPU consumption is done with"))
            .body(not(containsString("Java17")))
            .body(endsWith("The result is persisted in the database."));
    }
----

And we do the same for the `memory` method.

[[quarkus-listing-test-4]]
.Testing the Memory Endpoint
[source,java,indent=0,role=copy]
----
    @Test
    public void testMemoryWithDBAndDescEndpoint() {
        given().param("bites", 1).param("db", true).param("desc", "Java17")
          .when().get("/quarkus/memory")
          .then()
            .statusCode(200)
            .body(startsWith("Quarkus: Memory consumption is done with"))
            .body(not(containsString("Java17")))
            .body(endsWith("The result is persisted in the database."));
    }
----

Let's also create a simple test to make sure the statistics are stored in the database.

[[quarkus-listing-test-5]]
.Testing Retrieving the Statistics from the Database
[source,java,indent=0,role=copy]
----
    @Test
    public void testStats() {
        given()
          .when().get("/quarkus/stats")
          .then()
            .statusCode(200);
    }
----

Now that you have your tests methods, run them with the following command:

[source,shell,role=copy]
----
mvn test
----

All the tests should pass and you should see the following output:

[source,shell]
----
[INFO] Tests run: 4, Failures: 0, Errors: 0, Skipped: 0
[INFO]
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
----

[TIP]
====
You can also use the Task Manager to trigger Maven Test by executing the task `02: Quarkus - Test` which triggers a `mvn test` in a separate Terminal.
====

== Running the Quarkus Application Locally

Now that the tests are all green, let's execute the application locally and execute a few `curl` commands.
Make sure you still have Docker up and running and execute the following command under the `quarkus-app` directory:

[source,shell,role=copy]
----
mvn quarkus:dev
----

[TIP]
====
You can also use the Task Manager to start Quarkus in Dev Mode by executing the task `03: Quarkus - Start in dev mode (Hot reload + debug)` which triggers a `mvn quarkus:dev` in a separate Terminal.
====

image::../imgs/module-3/VSCode_task_manager_mvn_quarkus-dev.gif[Task Manager - Quarkus dev mode]

[NOTE]
====
When you start a Quarkus app in dev mode inside your Workspace watch out for two pop-ups that appear at the bottom left of your IDE.

 * the first one says "A new process is listening on port 5005..." which is the JVM Debug port. Just ignore and close this one.
 * the second one says "Process quarkus-app is now listening on port 8701" which is the http port we configured our app to listen to. *click Open in a new tab button* and then *click Open* in the next pop-up (VSCode needs your consent every time you attempt to open an external URL).

This pop-up will appear every time you start a process which listens to a TCP/HTTP port. This is how *DevSpaces* exposes your app for external access during development phase.
====

In another terminal you can execute the following `curl` commands to invoke the endpoint:

[source,shell]
----
curl 'localhost:8701/quarkus'

curl 'localhost:8701/quarkus/cpu?iterations=10&db=true&desc=java17'

curl 'localhost:8701/quarkus/memory?bites=10&db=true&desc=java17'
----

[TIP]
====
To open a new Terminal in your Worksapce just click the `+` icon located at the top bar of the Terminal panel. If your Teminal is not open just hit `Ctrl + \`` (`command + \`` for Mac).

You can also open a new Terminal by using the VSCode Command prompt by `Ctrl + Shift + P` (`command + Shift + P` on Mac) and typing `new terminal` and choosing the last option named `New Terminal to DevWorkspace Container`.
====

You can change the parameters to see how the application behaves.
Change the number of iterations and the number of bites to see how the performance is impacted (with and without database).

[source,shell]
----
curl 'localhost:8701/quarkus/cpu?iterations=50'
curl 'localhost:8701/quarkus/cpu?iterations=100'
curl 'localhost:8701/quarkus/cpu?iterations=100&db=true&desc=smoke%20test'

curl 'localhost:8701/quarkus/memory?bites=50'
curl 'localhost:8701/quarkus/memory?bites=100'
curl 'localhost:8701/quarkus/memory?bites=100&db=true&desc=smoke%20test'
----

You can check the content of the database with:

[source,shell,role=copy]
----
curl -s 'localhost:8701/quarkus/stats' | jq
----

[NOTE]
====
when you are done testing your Quarkus app just go to the Terminal running the quarkus-app JVM process and hit `Ctrl + c` to terminal the JVM process.
====

== Setting up for Staging

To wrap up with our quarkus app we need to make two changes in its configuration:

1. set the http connector to listen to port 8080
2. connect to a Postgres Database instead of a H2DB.
+
We have already deployed one Postgres instance in the `{user}-staging` project namespace using the link:https://access.crunchydata.com/documentation/postgres-operator/v5/[Crunchy Data PGO Operator], so you don't need to worry about setting up Postgres yourself.
+

To make these changes open the `$PROJECT_SOURCE/quarkus-app/src/main/resources/application.properties` config file and add the following properties that will be taken in `prod` mode.

.Prod Configuration Properties
[source,properties,indent=0, role=copy]
----

# Prod Config
%prod.quarkus.http.port=8080

# Postgres DB connection
%prod.quarkus.datasource.db-kind=postgresql
%prod.quarkus.datasource.username=postgres
%prod.quarkus.datasource.password=password
%prod.quarkus.datasource.jdbc.url=jdbc:postgresql://postgres-ha/postgres
%prod.quarkus.hibernate-orm.database.generation=none
----

== Push our changes to Github

Alright, now lets push this change to our git repo. From the DevWorkspace Terminal execute:

[source,shell]
----
cd $PROJECT_SOURCE/
git add .
git commit -m "adding PostgresDB connection properties"
git push
----

[TIP]
====
You can also use the VSCode integrated Source Control extension to commit and push your changes.

.See to use it here
[%collapsible]
======
image::../imgs/module-3/VSCode_git_commit_push.gif[VSCode integrated Source Control - git sync]
======
====

That's it for the Quarkus application.
Now, let's move to the Micronaut application.
